<!doctype html>
<html lang="es">
<head>
  <link rel="manifest" href="./manifest.webmanifest">
<meta name="theme-color" content="#0b1220">

<!-- iOS (Safari): no usa bien el manifest, necesita estos meta + icon -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="DECLARATRON">
<link rel="apple-touch-icon" href="./icons/icon-192.png">
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>DECLARATRON</title>

  <style>
  :root{
    /* iOS-like dark palette */
    --bg: #0b0f14;
    --surface: rgba(255,255,255,.06);
    --surface-2: rgba(255,255,255,.10);
    --border: rgba(255,255,255,.10);
    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.62);
    --hairline: rgba(255,255,255,.08);

    --blue: #0A84FF;     /* iOS system blue */
    --green: #34C759;    /* iOS system green */
    --red: #FF453A;      /* iOS system red */
    --orange: #FF9F0A;   /* iOS system orange */

    --radius: 16px;
    --radius-sm: 12px;
    --shadow: 0 12px 30px rgba(0,0,0,.38);
  }

  *{ box-sizing:border-box; }
  /* Let the page grow; avoid background cutoff quirks */
  html,body{ min-height:100%; }
  html{ background:#0b0f14; }

  body{
    margin:0;
    padding:16px;
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;
    color:var(--text);
    background:none; /* handled by ::before */
    min-height:100dvh;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  /* Continuous background layer */
  body::before{
    content:"";
    position:fixed;
    inset:0;
    z-index:-1;
    background:
      radial-gradient(1200px 700px at 20% -10%, rgba(10,132,255,.18), transparent 60%),
      radial-gradient(900px 600px at 90% 10%, rgba(52,199,89,.10), transparent 55%),
      linear-gradient(180deg, #0b0f14, #0a0d12);
  }

  /* Layout */
  .app{
    max-width: 980px;
    margin: 0 auto;
    display: grid;
    gap: 14px;
  }

  .topbar{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:12px;
    padding: 14px 14px;
    background: var(--surface);
    border: 1px solid var(--hairline);
    border-radius: 9999px;
    backdrop-filter: blur(14px);
    /* box-shadow removed for capsule header */
  }

  .brand{
    display:flex;
    align-items:baseline;
    gap:10px;
    min-width: 0;
  }

  h1{
    margin:0;
    font-size: 18px;
    line-height: 1.2;
    font-weight: 700;
    letter-spacing: .2px;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .subtitle{
    font-size: 12px;
    color: var(--muted);
    white-space: nowrap;
  }

  /* Card */
  .card{
    background: var(--surface);
    border: 1px solid var(--hairline);
    border-radius: var(--radius);
    padding: 14px;
    backdrop-filter: blur(14px);
    box-shadow: var(--shadow);
  }

  .section{
    border: 1px solid var(--hairline);
    border-radius: var(--radius);
    overflow: hidden;
    background: rgba(255,255,255,.03);
  }

  .sectionHeader{
    padding: 12px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    border-bottom: 1px solid var(--hairline);
  }

  .sectionTitle{
    font-size: 12px;
    letter-spacing: .3px;
    color: var(--muted);
    text-transform: uppercase;
  }

  .sectionBody{ padding: 12px; }

  /* Form grid */
  .fields{ display:grid; gap:12px; grid-template-columns: 1fr; }
  @media(min-width:820px){ .fields{ grid-template-columns: 1fr 1fr; } }
  .span2{ grid-column: 1 / -1; }

  label{
    display:block;
    font-size: 12px;
    color: var(--muted);
    margin: 0 0 6px;
  }

  input, select, textarea{
    width:100%;
    padding: 12px 12px;
    border-radius: var(--radius-sm);
    background: rgba(255,255,255,.06);
    border: 1px solid rgba(255,255,255,.10);
    color: var(--text);
    outline: none;
    transition: border-color .15s ease, background .15s ease;
  }

  /* iOS: <select> ignora min-height; usar height expl√≠cita */
  input, select{ height: 38px; }
  textarea{ min-height: 140px; resize: vertical; }
  input:focus, select:focus, textarea:focus{ border-color: rgba(10,132,255,.65); }

  /* Make selects visually match inputs on iOS */
  select{
    -webkit-appearance: none;
    appearance: none;
    padding-right: 38px; /* room for chevron */
    line-height: 1.2;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='rgba(255,255,255,.55)' d='M5.25 7.5 10 12.25 14.75 7.5 16 8.75 10 14.75 4 8.75z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 12px center;
    background-size: 18px 18px;
  }

  /* Validation (no glows) */
  input.valid,select.valid{ border-color: rgba(52,199,89,.7) !important; }
  input.invalid,select.invalid{ border-color: rgba(255,69,58,.75) !important; }
  input.uncertain, select.uncertain, textarea.uncertain{ border-color: rgba(255,159,10,.75) !important; }

  /* Buttons (iOS-like) */
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .row.center{ justify-content:center; }

  .btn{
    appearance: none;
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.06);
    color: var(--text);
    padding: 10px 12px;
    border-radius: 9999px;
    cursor: pointer;
    font-weight: 650;
    letter-spacing: .2px;
    transition: transform .12s ease, background .15s ease, border-color .15s ease;
  }
  .btn:hover{ background: rgba(255,255,255,.09); }
  .btn:active{ transform: scale(.98); }
  .btn:focus{ outline: 2px solid rgba(10,132,255,.45); outline-offset: 2px; }

  .btn.secondary{
    background: transparent;
    border-color: rgba(255,255,255,.14);
    font-weight: 600;
  }

  /* Semantic accents without halos */
  #gptComparecencia{ border-color: rgba(10,132,255,.55); }
  #btnDiligencia{ border-color: rgba(52,199,89,.55); }
  #clearForm{ border-color: rgba(255,69,58,.65); }

  /* Compact icon button */
  #readAnalyzeFile{
    padding: 10px 12px;
    font-size: 18px;
    line-height: 1;
  }

  /* Pills / badges */
  .badge{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding: 6px 10px;
    border-radius: 9999px;
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.06);
    color: var(--muted);
    font-size: 12px;
    white-space: nowrap;
  }

  /* List (chips) */
  ul.list{ list-style:none; margin:0; padding:0; display:flex; flex-wrap:wrap; gap:8px; }
  ul.list li{
    display:flex;
    align-items:center;
    gap:8px;
    border-radius: 9999px;
    padding: 8px 10px;
    background: rgba(255,255,255,.05);
    border: 1px solid rgba(255,255,255,.10);
    font-size: 12px;
  }
  ul.list li button{ margin-left: 2px; }

  /* Toolbar row: keep centered, no absolute positioning */
  .toolbar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    flex-wrap: wrap;
  }
  .toolbarLeft{ display:flex; gap:10px; align-items:center; }
  .toolbarCenter{ display:flex; gap:10px; align-items:center; justify-content:center; flex:1; }
  .toolbarRight{ display:flex; gap:10px; align-items:center; }

  /* Modal */
  .modal{
    position:fixed; inset:0; display:none;
    align-items:center; justify-content:center;
    background: rgba(0,0,0,.58);
    z-index: 9999;
    padding: 16px;
  }
  .modal.open{ display:flex; }
  .modal .panel{
    width: min(520px, 96vw);
    background: rgba(20,24,30,.92);
    border: 1px solid rgba(255,255,255,.12);
    border-radius: var(--radius);
    padding: 14px;
    box-shadow: 0 20px 60px rgba(0,0,0,.6);
    backdrop-filter: blur(16px);
  }
  .modal .panel h2{ margin:0 0 10px; font-size: 16px; }
  .modal .panel .fields2{ display:grid; gap:10px; grid-template-columns: 1fr; }
  @media(min-width:520px){ .modal .panel .fields2{ grid-template-columns: 1fr 1fr; } }

  /* Mobile spacing and responsive topbar */
  @media(max-width:520px){
    body{
      padding: calc(12px + env(safe-area-inset-top))
               calc(12px + env(safe-area-inset-right))
               calc(12px + env(safe-area-inset-bottom))
               calc(12px + env(safe-area-inset-left));
    }

    .app{ gap: 12px; }

    .topbar{
      align-self: center;
      width: fit-content;
      max-width: calc(100% - 24px);
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 16px;
      border-radius: 9999px;
    }

    .brand{
      width: 100%;
      align-items: baseline;
      gap: 8px;
      min-width: 0;
    }

    h1{ font-size: 17px; }

    .subtitle{
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .authBox{
      width: 100%;
      justify-content: flex-end;
      flex-wrap: wrap;
      gap: 8px;
    }

    .authBox .badge{
      flex: 1 1 100%;
      justify-content: flex-end;
    }

    .btn{ padding: 10px 11px; }
  }
  /* Header principal fijo como "capsule" centrada (sin ocupar todo el ancho visual) */
.topbar.fixed{
  position: sticky;
  top: calc(env(safe-area-inset-top, 0px) + 8px);
  z-index: 1000;
  width: fit-content;
  max-width: calc(100% - 24px);
  margin: 0 auto;
  padding: 10px 16px;
  border-radius: 9999px;
  background: rgba(255,255,255,.06);
  border: 1px solid var(--hairline);
  box-shadow: 0 10px 24px rgba(0,0,0,.28);
}

.topbar.fixed .brandTitle{
  justify-content: center;
  text-align: center;
}

/* T√≠tulo principal */
.brandTitle{
  margin: 0;
  font-size: 22px;
  font-weight: 800;
  letter-spacing: .4px;
  display: flex;
  align-items: center;
  gap: 6px;
}

/* Abeja m√°s grande */
.brandTitle .bee{
  font-size: 28px;
  line-height: 1;
}

/* Segunda fila (no fija) */
.subbar{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 10px 14px;
  margin-top: 10px;

  background: var(--surface);
  border: 1px solid var(--hairline);
  border-radius: var(--radius);
  backdrop-filter: blur(14px);
}

/* Ajuste m√≥vil */
@media (max-width: 520px){
  .subbar{
    flex-wrap: wrap;
    gap: 8px;
  }
  .subbar .subtitle{
    flex: 1 1 100%;
  }
}
  </style>
</head>
<body>
<div class="app">
 <header class="topbar fixed">
  <h1 class="brandTitle">
    LABEJAR <span class="bee">üêù</span>
  </h1>
</header>

<div class="subbar">
  <span class="subtitle">Filiaci√≥n, denuncia y diligencias</span>

  <div class="row authBox" style="margin:0">
    <span class="badge" id="authBadge" title="Credenciales para el backend">Sin acceso</span>
    <button class="btn secondary" id="btnAuth" title="Configurar acceso">Acceso</button>
    <button class="btn secondary" id="btnLogout" title="Borrar acceso" style="display:none">Salir</button>
  </div>
</div>

  <div class="card">
    <div class="fields">


      <!-- 1) BOTONES DNI: Foto + Archivo -->
      <div class="span2">
        <div class="row center" style="margin:6px 0 10px 0">
          <button class="btn" style="display:none" id="readAnalyze">ID üì∑</button>
          <button class="btn secondary" id="readAnalyzeFile">üì∑</button>
          <input type="file" id="dniCameraInput" accept="image/*" capture="environment" style="display:none">
          <input type="file" id="dniFileInput" accept="image/*" style="display:none">
        </div>
      </div>

      <!-- 2) CAMPOS FILIACI√ìN -->
       <div><label>Condici√≥n</label>
        <select id="Condicion">
          <option></option><option>Perjudicado</option><option>Testigo</option>
        </select>
      </div>
       <div><label>Tel√©fono</label><input id="Telefono" inputmode="numeric" pattern="[0-9 ]*"></div>
      <div><label>Nombre</label><input id="Nombre"></div>
      <div><label>Apellidos</label><input id="Apellidos"></div>
      <div><label>Tipo de documento</label><input id="Tipo"></div>
      <div><label>N¬∫ documento</label><input id="Numero"></div>
      <div><label>Sexo</label>
        <select id="Sexo"><option></option><option>MASCULINO</option><option>FEMENINO</option></select>
      </div>
      <div><label>Nacionalidad</label><input id="Nacionalidad"></div>
      <div class="span2"><label>Nombre de los Padres</label><input id="Padres"></div>
      <div><label>Fecha de nacimiento</label><input id="Nacimiento"></div>
      <div><label>Lugar de nacimiento</label><input id="Lugar"></div>
      <div class="span2"><label>Domicilio</label><input id="Domicilio"></div>
     
      <!-- 3) FILIACI√ìN (se guarda autom√°ticamente al Descargar) -->
      <div class="span2" style="height:6px"></div>

     <div class="span2 toolbar" style="margin-top:8px">
  <div class="toolbarLeft">
    <button class="btn" id="gptComparecencia" title="Abrir Denuncia">Denuncia</button>
  </div>

  <div class="toolbarCenter" style="justify-content:center">
    <button class="btn" id="integrarDoc" title="Pegar desde portapapeles" aria-label="Pegar">üìã</button>
  </div>

  <div class="toolbarRight" style="justify-content:flex-end">
    <button class="btn" id="btnDiligencia" title="Abrir Diligencia">Diligencia</button>
  </div>
</div>

      <!-- 6) DOC -->
      <div class="span2">
        <textarea id="Doc"></textarea>
      </div>

      <!-- 7) RESTO BOTONES (sin cifrado) -->
     <div class="span2 row" style="margin-top:10px; justify-content:space-between">
  <div class="row" style="margin:0">
    <button class="btn secondary" id="btnPlantillaHechos" title="Plantilla r√°pida para pegar en GPT">Plantilla</button>
  </div>

  <div class="row" style="margin:0; justify-content:center; gap:10px">
    <button class="btn" id="download">‚¨áÔ∏è Descargar</button>
    <button class="btn secondary" style="display:none" id="loadPlain">‚¨ÜÔ∏è Cargar</button>
    <input type="file" id="plainInput" accept=".json" style="display:none">
  </div>

  <div class="row" style="margin:0; justify-content:flex-end">
    <button class="btn secondary broom" id="clearForm" title="Limpiar formulario">üßπ</button>
  </div>
</div>

      </div>
    </div>
  </div>
<script src="plantillagpt.js"></script>
<script src="provincias_es.js"></script>
<script src="municipios.js"></script>
<script src="paises.js"></script>
<script src="calles.js"></script>
<script>
// ======================================================
// FILIATRON ‚Äî PARSER NS (1 sola l√≠nea, sin espacios)
// ======================================================

const expediente = { doc: "", filiaciones: [] };


// ---------- Helpers texto ----------
const tcase = s => (s||"").toLowerCase().replace(/\b([A-Za-z√Å√â√ç√ì√ö√ú√ë√°√©√≠√≥√∫√º√±])/g,c=>c.toUpperCase());
const normalize = s => (s||"").normalize('NFD').replace(/[\u0300-\u036f]/g, '').toUpperCase();
const normAZ = s => (s||"").normalize('NFD').replace(/[\u0300-\u036f]/g,'').toUpperCase()
  .replace(/[^A-Z√ë√Å√â√ç√ì√ö√ú\s-]/g,'').replace(/\s+/g,' ').trim();

// Construye NS (sin espacios) y mapa de √≠ndices a RAW
function buildNS(raw){
  const up0 = normalize(raw||"");
  // Normaliza variantes OCR del separador MRZ "<" (japon√©s '„Åè' y full-width 'Ôºú')
  const up = up0.replace(/„Åè/g,'<').replace(/Ôºú/g,'<');
  let NS = ""; const MAP = [];
  for (let i=0;i<up.length;i++){
    const ch = up[i];
    if (/\s/.test(ch)) continue;
    NS += ch; MAP.push(i);
  }
  return { NS, MAP, RAW: raw||"", UPROW: up };
}

// ---------- Distancia (fuzzy) ----------
function damerauLevenshtein(a,b,limit=2){
  a=a||""; b=b||""; if(a===b) return 0; if(!a||!b) return Math.min(limit+1, Math.max(a.length,b.length));
  const al=a.length, bl=b.length; if (Math.abs(al-bl)>limit) return limit+1;
  const dp=Array.from({length:al+1},()=>Array(bl+1).fill(0));
  for(let i=0;i<=al;i++) dp[i][0]=i; for(let j=0;j<=bl;j++) dp[0][j]=j;
  for(let i=1;i<=al;i++){
    let minRow=limit+1;
    for(let j=1;j<=bl;j++){
      const cost=a[i-1]===b[j-1]?0:1;
      let v=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
      if(i>1&&j>1&&a[i-1]===b[j-2]&&a[i-2]===b[j-1]) v=Math.min(v, dp[i-2][j-2]+1);
      dp[i][j]=v; if(v<minRow) minRow=v;
    }
    if(minRow>limit) return limit+1;
  }
  return dp[al][bl];
}

// --- Helper: localizar etiqueta con hasta 2 errores OCR (aprox) ---
function findApproxTag(ns, tag, maxDist = 2) {
  const T = tag.toUpperCase().replace(/\s+/g,'');
  const L = T.length;
  let best = { idx: -1, d: maxDist + 1 };
  for (let i = 0; i <= ns.length - L; i++) {
    const win = ns.slice(i, i + L);
    const d = damerauLevenshtein(win, T, maxDist);
    if (d <= maxDist && (d < best.d || best.idx === -1)) {
      best = { idx: i, d };
      if (d === 0) break;
    }
  }
  return best.idx;
}

// ---------- Librer√≠as (municipios / provincias / nombres) ----------
let MUNICIPIOS_SET = new Set([
  // Fallback m√≠nimo (por si fetch falla en file://)
  "MADRID","ALCOBENDAS","BARCELONA","VALENCIA","SEVILLA","MALAGA","MURCIA",
  "SANTA CRUZ DE TENERIFE","LAS PALMAS","ARONA","ADEJE","TELDE","VIGO","OVIEDO","GIJON","BILBAO","VALLADOLID","SALAMANCA","TOLEDO"
].map(normalize));
// Mapa normalize(mun) -> mun can√≥nico (tal cual viene en la librer√≠a)
let MUNICIPIOS_CANON = new Map();
// Por defecto, si estamos en fallback, el can√≥nico es el propio valor normalizado
MUNICIPIOS_CANON = new Map([...MUNICIPIOS_SET].map(m => [m, m]));
let MUNICIPIOS_NOSPACE = new Map([...MUNICIPIOS_SET].map(m => [m.replace(/\s+/g,''), m]));

const PROVINCIAS = [
  "A CORU√ëA","ALAVA","ALAVA","ALBACETE","ALICANTE","ALMERIA","ALMERIA","ASTURIAS","√ÅVILA","AVILA",
  "BADAJOZ","BARCELONA","BIZKAIA","VIZCAYA","BURGOS","C√ÅCERES","CACERES","C√ÅDIZ","CADIZ","CANTABRIA",
  "CASTELLON","CASTELLON","CIUDAD REAL","C√ìRDOBA","CORDOBA","CUENCA","GIRONA","GERONA","GRANADA",
  "GUADALAJARA","GUIP√öZCOA","GUIPUZCOA","GIPUZKOA","HUELVA","HUESCA","ILLES BALEARS","ISLAS BALEARES",
  "JA√âN","JAEN","LA RIOJA","LAS PALMAS","LE√ìN","LEON","LLEIDA","LUGO","MADRID","M√ÅLAGA","MALAGA",
  "MURCIA","NAVARRA","NAFARROA","OURENSE","ORENSE","PALENCIA","PONTEVEDRA","SALAMANCA",
  "SANTA CRUZ DE TENERIFE","SEGOVIA","SEVILLA","SORIA","TARRAGONA","TERUEL","TOLEDO",
  "VALENCIA","VALLADOLID","ZAMORA","ZARAGOZA","CEUTA","MELILLA"
].map(normalize);
const PROV_SET = new Set(PROVINCIAS);
const PROV_NOSPACE = new Map([...PROV_SET].map(p => [p.replace(/\s+/g,''), p]));

let NOMBRES_SET = new Set(); // se cargar√° de nombres.json si se puede

async function initMunicipios(){
  try{
    // municipios.js ya est√° incluido como <script>, as√≠ que debe exponer un array global.
    // Aceptamos varios nombres habituales para evitar acoplar a uno solo.
    const arr = (typeof window !== 'undefined')
      ? (window.MUNICIPIOS || window.municipios || window.Municipios || window.MUNICIPIOS_ES || null)
      : null;

    if (Array.isArray(arr) && arr.length){
      // Conserva el can√≥nico EXACTO (con "DE", acentos, etc.) y usa normalize solo para matching.
      const rawList = arr
        .map(x => String(x || "").trim())
        .filter(Boolean);

      MUNICIPIOS_SET = new Set(rawList.map(normalize));
      MUNICIPIOS_CANON = new Map(rawList.map(v => [normalize(v), v]));
      MUNICIPIOS_NOSPACE = new Map(rawList.map(v => [normalize(v).replace(/\s+/g,''), v]));

      console.log(`Municipios cargados (municipios.js): ${MUNICIPIOS_SET.size}`);
      return;
    }

    console.warn('municipios.js no expuso un array global esperado. Uso fallback.');
  }catch(e){
    console.warn('Error leyendo municipios.js (global). Uso fallback.', e);
  }
}
async function initNombres(){
  try{
    const res = await fetch('nombres.json', {cache:'no-store'});
    if (!res.ok) throw new Error('HTTP '+res.status);
    const arr = await res.json();
    if (Array.isArray(arr) && arr.length){
      // nombres.json tiene l√≠neas tipo "AARON,21540,11.0" o nombres compuestos
      // extrae solo el campo de nombre (antes de la primera coma)
      const list = arr.map(line => String(line).split(',')[0]).filter(Boolean);
      NOMBRES_SET = new Set(list.map(normalize));
      console.log(`Nombres cargados: ${NOMBRES_SET.size}`);
    }
  }catch(e){
    console.warn('nombres.json no accesible (¬øfile:// / CORS?). Padres quedar√°n en duda si no hay set.', e);
  }
}

// ---------- Matching municipio / provincia ----------
function matchMunicipioSuffixNS(ns){
  if (!ns || !MUNICIPIOS_NOSPACE.size) return null;
  const maxLen = Math.min(32, ns.length);
  for (let len = maxLen; len >= 4; len--) {
    const sub = ns.slice(ns.length - len);
    const hit = MUNICIPIOS_NOSPACE.get(sub);
    if (hit) return { canon: hit, index: ns.length - len };
  }
  return null;
}
function findProvinceAfter(ns, start=0){
  if (!ns) return null;
  let best = null;
  for (const [pNS, canon] of PROV_NOSPACE.entries()){
    const idx = ns.indexOf(pNS, start);
    if (idx !== -1){
      if (!best || idx < best.index || (idx === best.index && pNS.length > best.pNS.length)){
        best = { index: idx, canon, pNS };
      }
    }
  }
  return best;
}
function matchMunicipio(raw){
  const cand = normAZ(raw);
  const can  = normalize(cand);
  if (MUNICIPIOS_SET.has(can)) {
    const canonExact = MUNICIPIOS_CANON.get(can) || cand;
    return {canon: canonExact, approx:false, found:true};
  }
  let best=null, bestD=3;
  for (const m of MUNICIPIOS_SET){
    const d = damerauLevenshtein(can, m, 2);
    if (d<bestD){ bestD=d; best=m; if (d===0) break; }
  }
  if (best!=null && bestD<=2) {
    const canonExact = MUNICIPIOS_CANON.get(best) || best;
    return {canon: String(canonExact).replace(/\s+/g,' ').trim(), approx:true, found:true};
  }
  return {canon:cand, approx:false, found:false};
}

// ---------- MRZ helpers ----------
function mapDigit(ch){
  if (/[0-9]/.test(ch)) return ch;
  const t = ch.toUpperCase();
  if (t==='O'||t==='Q') return '0';
  if (t==='I'||t==='L') return '1';
  if (t==='Z') return '2';
  if (t==='S') return '5';
  if (t==='B') return '8';
  return '0';
}
// ---------- PASAPORTE (TD3) ----------
// Parser cerrado: usa MRZ como fuente principal y usa el cuerpo solo como refuerzo cuando hay duda.
function parsePassportByMRZ(ocrRaw){
  const built = buildNS(ocrRaw);
  const NS = built.NS;
  const RAW = built.RAW;

  // Detecta inicio MRZ de pasaporte: "P<" (TD3)
  const idxP = NS.indexOf('P<');
  if (idxP === -1) return null;

  // Reconstruir L1/L2 (TD3: 2 l√≠neas de 44)
  const win = NS.slice(idxP, Math.min(NS.length, idxP + 120));
  const lines = win.split(/\n/).filter(Boolean);

  let l1 = "", l2 = "";
  if (lines.length >= 2) {
    l1 = String(lines[0] || "").replace(/\s+/g, "");
    l2 = String(lines[1] || "").replace(/\s+/g, "");
  } else {
    const flat = win.replace(/\s+/g, "");
    l1 = flat.slice(0, 44);
    l2 = flat.slice(44, 88);
  }
  l1 = (l1 || "").padEnd(44, '<').slice(0, 44);
  l2 = (l2 || "").padEnd(44, '<').slice(0, 44);

  // Helpers MRZ
  const mapDigitMRZ = (ch)=>{
    if (/[0-9]/.test(ch)) return ch;
    const t = String(ch||"").toUpperCase();
    if (t==='O'||t==='Q') return '0';
    if (t==='I'||t==='L') return '1';
    if (t==='Z') return '2';
    if (t==='S') return '5';
    if (t==='B') return '8';
    return ch; // el n¬∫ de pasaporte puede llevar letras
  };
  const clean = (s)=>String(s||"").replace(/</g,' ').replace(/\s+/g,' ').trim();

  // TD3
  const issuing = l1.slice(2,5);              // ISO3 emisor
  const namesPart = l1.slice(5);              // apellidos<<nombres
  const parts = namesPart.split('<<');
  const sur = clean(parts[0] || "").toUpperCase();
  const giv = tcase(clean((parts[1] || "").replace(/</g,' ')));

  const docNumRaw = l2.slice(0,9);
  const docNum = docNumRaw.replace(/</g,'').split('').map(mapDigitMRZ).join('').toUpperCase();

  const nat = l2.slice(10,13).replace(/</g,'').toUpperCase();  // ISO3 nacionalidad

  const dob6 = l2.slice(13,19).split('').map(mapDigitMRZ).join('');
  const sex = (l2.slice(20,21) || '').toUpperCase();

  const ddmmyyyy = (yymmdd)=>{
    if (!/^\d{6}$/.test(yymmdd)) return "";
    const yy = parseInt(yymmdd.slice(0,2),10);
    const mm = yymmdd.slice(2,4);
    const dd = yymmdd.slice(4,6);
    const nowYY = new Date().getFullYear() % 100;
    const yyyy = (yy > nowYY ? 1900 + yy : 2000 + yy);
    return `${dd}/${mm}/${yyyy}`;
  };

  const fechaNac = ddmmyyyy(dob6);
  const sexo = (sex === 'F') ? 'FEMENINO' : (sex === 'M') ? 'MASCULINO' : "";

  // Refuerzo: n¬∫ pasaporte tambi√©n suele estar impreso en el cuerpo (VIZ). Solo cuenta si coincide exacto.
  const bodyHit = (docNum && docNum.length >= 6)
    ? new RegExp(`\\b${docNum.replace(/[.*+?^${}()|[\\]\\]/g,'\\$&')}\\b`, 'i').test(RAW)
    : false;

  return {
    Nombre: tcase(giv),
    Apellidos: (sur || "").toUpperCase(),
    "Tipo de documento": "PASAPORTE",
    "N¬∫ Documento": docNum,
    Sexo: sexo,
    Nacionalidad: nat || "",
    "Nombre de los Padres": "",
    "Fecha de nacimiento": fechaNac,
    "Lugar de nacimiento": "",
    Domicilio: "",
    _flags:{
      Nombre: !giv,
      Apellidos: !sur,
      Padres: true,
      Lugar: true,
      Domicilio: true,
      Numero: !docNum || !bodyHit
    },
    _mrz:{ l1, l2, issuing }
  };
}

// Wrapper: decide por MRZ qu√© parser ejecutar (sin tocar el DNI existente)
function parseDocument(ocrRaw){
  const maybePass = parsePassportByMRZ(ocrRaw);
  if (maybePass) return maybePass;
  return parseByRules(ocrRaw);
}
// ---------- Parser principal (NS) ----------
function parseByRules(ocrRaw){
  // --- construir NS y, si empieza por EQUIPO, recortar hasta DOMICILIO ---
  {
    const built = buildNS(ocrRaw);
    let NS0 = built.NS, MAP0 = built.MAP, RAW0 = built.RAW;

    // Si la cadena NS empieza con EQUIPO... eliminar "EQUIPO" + alfanum√©rico hasta "DOMICILIO"
    if (NS0.startsWith('EQUIPO')) {
      const idxDomStart = NS0.indexOf('DOMICILIO');
      if (idxDomStart !== -1) {
        NS0  = NS0.slice(idxDomStart);
        MAP0 = MAP0.slice(idxDomStart); // mantiene alineado el mapeo RAW
      }
    }

    // Exponer a la funci√≥n con los mismos nombres que usas abajo
    var NS = NS0, MAP = MAP0, RAW = RAW0;
  }

  // Anclajes
  // Normaliza confusiones OCR 1/l‚ÜíI, 0/O‚ÜíO, 5‚ÜíS, Q/C‚ÜíD (reemplazo 1:1, mantiene √≠ndice)
  const canonNS = NS.replace(/[l1]/g,'I').replace(/[0ÔºØ]/g,'O').replace(/5/g,'S').replace(/[QC]/g,'D');

  // IDESP robusto con variantes OCR (I/1/L)(D/Q/C/O/0)E(S/5)P  + casos IOESP/IOSEP
  const idxIDESP = (() => {
    const hits = [];

    // 1) patr√≥n general con confusiones
    const rx = /[IL1](?:D|Q|C|O|0)E(?:S|5)P/g;
    for (const m of canonNS.matchAll(rx)) hits.push(m.index);

    // 2) casos expl√≠citos hist√≥ricos
    const a = canonNS.indexOf('IOESP'); if (a !== -1) hits.push(a);
    const b = canonNS.indexOf('IOSEP'); if (b !== -1) hits.push(b);

    if (!hits.length) return -1;
    return Math.min(...hits);
  })();

  const idxEQUIPO = NS.indexOf('EQUIPO');
  const idxDOM = NS.indexOf('DOMICILIO');

  // Etiqueta de nacimiento (exacta primero)
  let idxLUG = (()=>{ 
    const a=NS.indexOf('LUGARDENACIMIENTO'); 
    if (a!==-1) return a; 
    return NS.indexOf('LAGARDENACIMIENTO');
  })();

  // Si no se encontr√≥ exacto, admite hasta 2 errores OCR
  if (idxLUG === -1) {
    const alt1 = findApproxTag(NS, 'LUGARDE NACIMIENTO', 2);
    const alt2 = findApproxTag(NS, 'LAGARDE NACIMIENTO', 2);
    idxLUG = (alt1 !== -1) ? alt1 : (alt2 !== -1 ? alt2 : -1);
  }

  const gStop = [idxIDESP, idxEQUIPO].filter(i=>i!==-1).reduce((m,i)=>Math.min(m,i), NS.length);

  // --- DOMICILIO ---
  let domicilio = "", domicilioUncertain = true;
  if (idxDOM !== -1){
    const start = idxDOM + 'DOMICILIO'.length;
    const aLUG = idxLUG === -1 ? Infinity : idxLUG;
    const aEQ  = idxEQUIPO === -1 ? Infinity : idxEQUIPO;
    const aID  = idxIDESP === -1 ? Infinity : idxIDESP;
    const pv   = findProvinceAfter(NS, start);
    const anchorEnd = Math.min(aLUG, aEQ, aID, NS.length);
    const end = (pv && pv.index < anchorEnd) ? pv.index : anchorEnd;

    let domNS = NS.slice(start, end).trim();
    const suf = matchMunicipioSuffixNS(domNS);

    // reconstruir calle legible
    const rawStart = MAP[start] ?? 0;
    const rawEndStreet = (suf ? MAP[start + suf.index - 1] : MAP[end - 1]) ?? MAP[MAP.length-1];
    let street = RAW.slice(rawStart, (rawEndStreet ?? rawStart)+1)
      .replace(/\s*,\s*/g, ', ')
      .replace(/\.([A-Za-z√Å√â√ç√ì√ö√ú√ë])/g, '. $1')
      .replace(/([A-Za-z√Å√â√ç√ì√ö√ú√ë])(\d)/g, '$1 $2')
      .replace(/(\d)([A-Za-z√Å√â√ç√ì√ö√ú√ë])/g, '$1 $2')
      .replace(/\s{2,}/g,' ')
      .trim();

    if (suf){
      domicilio = `${street}, ${tcase(suf.canon)}`;
      domicilioUncertain = false;
    } else {
      domicilio = street;
    }
  }

  // --- LUGAR NACIMIENTO ---
  let lugarNac = "", lugarUncertain = true;
  if (idxLUG !== -1){
    const start = idxLUG + (NS.startsWith('LUGARDENACIMIENTO', idxLUG) ? 'LUGARDENACIMIENTO'.length : 'LAGARDENACIMIENTO'.length);
    const aH  = (()=>{ const i=NS.indexOf('HIJOADE', start); return i!==-1?i:Infinity;})();
    const aID = idxIDESP !== -1 ? idxIDESP : Infinity;
    const aEQ = idxEQUIPO !== -1 ? idxEQUIPO : Infinity;
    const pv  = findProvinceAfter(NS, start);
    // no invadir el "DE" de padres
    const idxH = NS.indexOf('HIJOADE', start);
    const limitDE = (idxH!==-1) ? (NS.indexOf('DE', idxH+'HIJOADE'.length) || Infinity) : Infinity;

    const anchorEnd = Math.min(aH, aID, aEQ, NS.length, limitDE);
    const end = (pv && pv.index < anchorEnd) ? pv.index : anchorEnd;

    let seg = NS.slice(start, end);
    const cutNum = seg.search(/[0-9]/); if (cutNum !== -1) seg = seg.slice(0, cutNum);

    const mun = matchMunicipio(seg);
    if (pv){
      const prov = tcase(pv.canon);
      const mc = mun.found ? tcase(mun.canon) : tcase(seg);
      lugarUncertain = false;
      lugarNac = (!seg || normalize(mc)===normalize(pv.canon)) ? prov : `${mc}, ${prov}`;
    }else{
      lugarNac = mun.found ? tcase(mun.canon) : tcase(seg);
      if (!(mun.found && !mun.approx)) lugarUncertain = true;
    }
  }

  // --- PADRES (corte por 'ADE' ‚Üí IDESP; usa librer√≠a, no peta; descompone nombres pegados) ---
  let padres = "", padresUncertain = true;
  {
    const hasName = (tok)=>{
      if (!tok) return false;
      if (!NOMBRES_SET || NOMBRES_SET.size === 0) return false;
      return NOMBRES_SET.has(normalize(tok));
    };

    if (idxIDESP !== -1){
      // Buscar anclaje 'ADE' robusto (A[ D/Q/C/O/0 ]?E) sobre NS (sin espacios), antes de IDESP; ordenados
      const adeIdxs = (()=> {
        const out = [];
        const rx = /A[ DQCO0O]?E/g; // ADE, AOE, A0E, AQE, ACE y AE
        rx.lastIndex = 0;
        let m;
        while ((m = rx.exec(NS))) {
          const i = m.index;
          if (idxIDESP !== -1 && i < idxIDESP) out.push(i);
          if (idxIDESP !== -1 && i >= idxIDESP) break;
        }
        out.sort((a,b)=>a-b);
        return out;
      })();

      let candidates = adeIdxs;
      if (idxLUG !== -1){
        const afterLugar = adeIdxs.filter(i => i > idxLUG);
        if (afterLugar.length) candidates = afterLugar;
      }

      const extractPair = (segNS)=>{
        let seg = (segNS||"").replace(/[0-9]+/g,'').replace(/[\/\|_!¬°]+/g,'I');

        const deco = (s)=>{
          if (!s) return "";
          if (hasName(s)) return tcase(s);
          const C = s;
          for (let k=2; k<=Math.min(12, C.length-2); k++){
            const A = C.slice(0,k), B = C.slice(k);
            if (hasName(A) && hasName(B)) return `${tcase(A)} ${tcase(B)}`;
          }
          return "";
        };

        for (let j=1;j<seg.length-1;j++){
          if (seg[j] !== 'I') continue;
          const L = seg.slice(0,j), R = seg.slice(j+1);
          const Ld = deco(L), Rd = deco(R);
          if (Ld && Rd) return `${Ld} y ${Rd}`;
        }

        const compact = seg.replace(/I+/g,'');
        for (let m=2;m<=Math.min(24, compact.length-2);m++){
          const L = compact.slice(0,m), R = compact.slice(m);
          const Ld = deco(L), Rd = deco(R);
          if (Ld && Rd) return `${Ld} y ${Rd}`;
        }

        const toks = seg.split(/I+/).filter(Boolean);
        for (let a=0;a<toks.length;a++){
          for (let b=a+1;b<toks.length;b++){
            const Ld = deco(toks[a]), Rd = deco(toks[b]);
            if (Ld && Rd) return `${Ld} y ${Rd}`;
          }
        }
        return "";
      };

      if (candidates.length){
        const iADE = candidates[candidates.length - 1];
        const segNS = NS.slice(iADE + 3, idxIDESP);
        const pair = extractPair(segNS);
        if (pair){
          padres = pair; padresUncertain = false;
        } else {
          padres = ""; padresUncertain = true;
        }
      } else if (idxLUG !== -1){
        const start = idxLUG + (NS.startsWith('LUGARDENACIMIENTO', idxLUG) ? 'LUGARDENACIMIENTO'.length : 'LAGARDENACIMIENTO'.length);
        if (start < idxIDESP){
          const segNS = NS.slice(start, idxIDESP);
          const pair = extractPair(segNS);
          if (pair){
            padres = pair; padresUncertain = false;
          } else {
            padres = ""; padresUncertain = true;
          }
        }
      }

      if (padres){
        const parts = padres.split(/\s+y\s+/i);
        if (parts.length===2){
          const badA = PROV_SET.has(normalize(parts[0])) || MUNICIPIOS_SET.has(normalize(parts[0]));
          const badB = PROV_SET.has(normalize(parts[1])) || MUNICIPIOS_SET.has(normalize(parts[1]));
          if (badA || badB) padresUncertain = true;
        }
      }
    }
  }

  // --- PARCHE √öNICO: Provincia como final inclusivo + backfill DOMICILIO si falta ---
  (function(){
    // Helper: √∫ltima provincia ANTES de un √≠ndice dado en NS
    function lastProvinceBefore(limitIdx){
      let last = null;
      for (const [pNS, canon] of PROV_NOSPACE.entries()){
        const i = NS.lastIndexOf(pNS, limitIdx);
        if (i !== -1 && i <= limitIdx){
          if (!last || i > last.index || (i === last.index && pNS.length > last.pNS.length)){
            last = { index: i, canon, pNS };
          }
        }
      }
      return last;
    }

    // 1) NACIMIENTO: si idxLUG v√°lido y c√°lculo previo vac√≠o o en duda,
    // usa la PRIMERA provincia DESPU√âS de idxLUG como final inclusivo.
    if (idxLUG !== -1 && (!lugarNac || lugarUncertain)) {
      const start = idxLUG + (NS.startsWith('LUGARDENACIMIENTO', idxLUG) ? 'LUGARDENACIMIENTO'.length : (NS.startsWith('LAGARDENACIMIENTO', idxLUG) ? 'LAGARDENACIMIENTO'.length : 0));
      if (start > idxLUG) {
        const pv = findProvinceAfter(NS, start);
        if (pv) {
          // recorta hasta provincia (inclusiva)
          const rawStart = MAP[start] ?? 0;
          const rawEnd   = MAP[pv.index + pv.pNS.length - 1] ?? (MAP[MAP.length-1] || RAW.length-1);
          const segRaw   = RAW.slice(rawStart, rawEnd + 1);
          // normaliza
          const clean = segRaw.replace(/\s{2,}/g,' ').trim();
          const municipioGuess = matchMunicipio(clean);
          const provName = tcase(pv.canon);
          if (municipioGuess.found) {
            lugarNac = (normalize(municipioGuess.canon) === normalize(pv.canon))
              ? provName
              : `${tcase(municipioGuess.canon)}, ${provName}`;
          } else {
            lugarNac = `${tcase(clean.replace(/\s*,\s*/g, ', '))}`.replace(/\s+,/g, ',');
          }
          lugarUncertain = false;
        }
      }
    }

    // 2) DOMICILIO: si NO hay DOMICILIO claro (vac√≠o o incierto) y S√ç hay idxLUG,
    // toma la √öLTIMA provincia ANTES de idxLUG como fin inclusivo, y busca hacia atr√°s
    // un token de v√≠a razonable (o 'DOMICILIO' si existiera).
    if (( !domicilio || domicilioUncertain ) && idxLUG !== -1) {
      const pvPrev = lastProvinceBefore(idxLUG - 1);
      if (pvPrev) {
        // punto final inclusivo en RAW
        const rawEnd = MAP[pvPrev.index + pvPrev.pNS.length - 1] ?? (MAP[MAP.length-1] || RAW.length-1);
        // busca inicio en RAW hacia atr√°s: DOMICILIO o tokens de v√≠a
        const rawSearch = RAW.slice(0, rawEnd + 1);
        const viaRx = /(DOMICILIO|C\.\s*|AVDA|AVENIDA|CL\s|CALLE|PASEO|PSO)/gi;
        let m, lastMatch = null;
        while ((m = viaRx.exec(rawSearch))) lastMatch = m;
        if (lastMatch) {
          const rawStart = Math.max(0, lastMatch.index + (lastMatch[1].toUpperCase()==='DOMICILIO' ? 'DOMICILIO'.length : 0));
          let seg = RAW.slice(rawStart, rawEnd + 1)
            .replace(/\s*,\s*/g, ', ')
            .replace(/\s{2,}/g,' ')
            .trim();
          // engancha municipio y provincia si se reconocen
          const muni = matchMunicipio(seg);
          const provName = tcase(pvPrev.canon);
          if (muni.found && normalize(muni.canon) !== normalize(pvPrev.canon)) {
            if (!new RegExp(provName.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')+'\\s*$','i').test(seg)) {
              seg = `${tcase(muni.canon)}, ${provName}`;
            }
          } else if (!/,\s*[A-Z√Å√â√ç√ì√ö√ú√ë ]+$/.test(seg)) {
            seg = `${seg.replace(/\s+,/g, ',')}, ${provName}`;
          }
          domicilio = seg;
          domicilioUncertain = false;
        }
      }
    }
  })();

  // --- MRZ (L1/L2/L3) (SE MANTIENE IGUAL) ---
  let MRZ_L1 = "", MRZ_L2 = "", MRZ_L3 = "";
  if (idxIDESP !== -1) {
    // L1: desde IDESP hasta el PRIMER "<<<" que siga
    const firstArrows = NS.indexOf('<<<', idxIDESP);
    if (firstArrows !== -1) {
      MRZ_L1 = NS.slice(idxIDESP, firstArrows);

      // L2: buscar patr√≥n YYMMDD? + sexo [MF] en una VENTANA limitada tras el primer "<<<"
      const winEnd = Math.min(NS.length, firstArrows + 180);
      const winL2 = NS.slice(firstArrows + 3, winEnd);
      const mL2 = winL2.match(/([0-9A-Z]{2})([0-9A-Z]{2})([0-9A-Z]{2}).([MF])/);
      if (mL2) MRZ_L2 = mL2[0];

      // L3: tras "ESP" si existe; si no, tras la misma ventana; NO exige segundo "<<<"
      const idxESPwin = winL2.indexOf('ESP');
      let afterIdxAbs = firstArrows + 3;
      if (idxESPwin !== -1) afterIdxAbs = firstArrows + 3 + idxESPwin + 3;

      const nextArrows = NS.indexOf('<<<', afterIdxAbs);
      let l3Start = (nextArrows !== -1) ? nextArrows + 3 : afterIdxAbs;

      while (l3Start < NS.length && !/[A-Z<]/.test(NS[l3Start])) l3Start++;
      MRZ_L3 = NS.slice(l3Start, Math.min(NS.length, l3Start + 120));
    }
  }

  // N¬∫ doc desde L1/L2
  function docFromL1L2(l1,l2){
    if (!l1) return "";
    const m = l1.match(/<{3,}/);
    if (m){ const idx=m.index; if (idx>=9) return l1.slice(idx-9, idx).toUpperCase(); }
    if (l2){ const clean=l1.replace(/</g,''); if (clean.length>=9) return clean.slice(-9).toUpperCase(); }
    return "";
  }
  let numDoc = docFromL1L2(MRZ_L1, MRZ_L2);

  // Fecha y sexo desde L2 (mapDigit para confusiones)
  let fechaNac="", sexo="";
  if (MRZ_L2){
    const m = MRZ_L2.match(/([0-9A-Z]{2})([0-9A-Z]{2})([0-9A-Z]{2}).([MF])/);
    if (m){
      const yy = parseInt(mapDigit(m[1][0]) + mapDigit(m[1][1]),10);
      const mm = mapDigit(m[2][0]) + mapDigit(m[2][1]);
      const dd = mapDigit(m[3][0]) + mapDigit(m[3][1]);
      const year = yy >= 30 ? 1900 + yy : 2000 + yy;
      fechaNac = `${dd}/${mm}/${year}`;
      sexo = m[4] === 'F' ? 'FEMENINO' : 'MASCULINO';
    }
  }
// --- PATCH DE CORRECCI√ìN MRZ: limitar lectura a la zona antes del siguiente "ESP" o "<<<" ---
(function(){
  if (!MRZ_L1 && !MRZ_L2) return;

  // 1. Corregir N¬∫ Documento si IDESP contiene la secuencia correcta
  if (idxIDESP !== -1 && (!numDoc || numDoc.length < 8)) {
    const afterID = NS.slice(idxIDESP + 5, idxIDESP + 60); // mira los 60 caracteres tras IDESP
    const mDoc = afterID.match(/([A-Z0-9]{7,9})</); // DNI/NIE seguido de flecha
    if (mDoc) numDoc = mDoc[1].toUpperCase();
  }

  // 2. Corregir Fecha/Sexo si se detectan dentro de la l√≠nea posterior a IDESP
  if ((!fechaNac || !sexo) && idxIDESP !== -1) {
    const afterID = NS.slice(idxIDESP, idxIDESP + 120);
    const mL2 = afterID.match(/([0-9A-Z]{6})([MF])/);
    if (mL2) {
      const raw6 = mL2[1].split("").map(mapDigit).join("");
      const yy = parseInt(raw6.slice(0,2), 10);
      const mm = raw6.slice(2,4);
      const dd = raw6.slice(4,6);
      const year = yy >= 30 ? 1900 + yy : 2000 + yy;
      fechaNac = `${dd}/${mm}/${year}`;
      sexo = mL2[2] === 'F' ? 'FEMENINO' : 'MASCULINO';
    }
  }
})();
// === PATCH SOLO FECHA NAC (L2 = YYMMDD + check + M/F) ===
(function(){
  if (idxIDESP === -1) return;

  // si ya hay fecha v√°lida (dd/mm/aaaa) y plausible, no tocamos
  const okFecha = f => /^\d{2}\/\d{2}\/\d{4}$/.test(f) &&
                       (m=>m>=1&&m<=12)(parseInt(f.slice(3,5),10)) &&
                       (d=>d>=1&&d<=31)(parseInt(f.slice(0,2),10));
  if (fechaNac && okFecha(fechaNac)) return;

  const firstArrows = NS.indexOf('<<<', idxIDESP);
  if (firstArrows === -1) return;

  // M/F m√°s cercano hacia la izquierda desde el primer '<<<'
  let sexAt = -1;
  for (let p = firstArrows - 1; p >= idxIDESP; p--) {
    const ch = NS[p];
    if (ch === 'M' || ch === 'F') { sexAt = p; break; }
  }
  if (sexAt === -1) return;

  // L2: ... YYMMDD + check + (M/F)
  if (sexAt - 7 >= idxIDESP) {
    const raw7 = NS.slice(sexAt - 7, sexAt);        // 6 fecha + 1 check
    const raw6 = raw7.slice(0, 6).split('').map(mapDigit).join('');
    const yy = parseInt(raw6.slice(0,2), 10);
    const mm = parseInt(raw6.slice(2,4), 10);
    const dd = parseInt(raw6.slice(4,6), 10);
    if (mm >= 1 && mm <= 12 && dd >= 1 && dd <= 31) {
      const year = yy >= 30 ? 1900 + yy : 2000 + yy;
      fechaNac = `${String(dd).padStart(2,'0')}/${String(mm).padStart(2,'0')}/${year}`;
    }
  }
})();
  // Nacionalidad
  let Nacionalidad = (MRZ_L1.includes('ESP') || MRZ_L2.includes('ESP')) ? "Espa√±a" : "";

  // Apellidos/Nombre desde L3 (sin d√≠gitos)
  let nombre="", apellidos="";
  if (MRZ_L3){
    const parts = MRZ_L3.split('<').filter(Boolean);
    const ap1 = (parts[0]||"").replace(/[0-9]/g,'');
    const ap2 = (parts[1]||"").replace(/[0-9]/g,'');
    const nom1= (parts[2]||"").replace(/[0-9]/g,'');
    const nom2= (parts[3]||"").replace(/[0-9]/g,'');
    apellidos = [ap1,ap2].filter(Boolean).join(' ').trim().toUpperCase();
    nombre = tcase([nom1,nom2].filter(Boolean).join(' ').trim());
  }

  // Sanitizaci√≥n final
  const sanitize = s => (s||"").replace(/^[\s:.,-]+|[\s:.,-]+$/g,'').replace(/\s{2,}/g,' ').trim();
  let out = {
    Nombre: tcase(sanitize(nombre)),
    Apellidos: sanitize(apellidos).toUpperCase(),
    "Tipo de documento": "DNI",
    "N¬∫ Documento": sanitize(numDoc||""),
    Sexo: sanitize(sexo),
    Nacionalidad: sanitize(Nacionalidad),
    "Nombre de los Padres": tcase(sanitize(padres)).replace(/\sY\s/g,' y '),
    "Fecha de nacimiento": sanitize(fechaNac),
    "Lugar de nacimiento": tcase(sanitize(lugarNac)),
    Domicilio: tcase(sanitize(domicilio)),
    _flags:{
      Nombre: !nombre,
      Apellidos: !apellidos,
      Padres: padresUncertain,
      Lugar: lugarUncertain,
      Domicilio: domicilioUncertain
    }
  };
  return out;
}

// ---------- Canonicalizaci√≥n (PROVINCIAS/MUNICIPIOS/PAISES desde JS externos) ----------
// Requiere (si est√°n cargados):
//  - window.PROVINCIAS_ES (array)
//  - window.MUNICIPIOS_ES (objeto { PROV: [MUN...] })
//  - window.PAISES (objeto con grupos/items)

function _normKey(s){
  return (s||"")
    .toString()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .toUpperCase()
    .replace(/[^A-Z0-9\s\-\/]/g,'')
    .replace(/\s+/g,' ')
    .trim();
}

function _buildCanonIndexes(){
  const provArr = Array.isArray(window.PROVINCIAS_ES) ? window.PROVINCIAS_ES : [];
  const muniObj = (window.MUNICIPIOS_ES && typeof window.MUNICIPIOS_ES === 'object') ? window.MUNICIPIOS_ES : null;

  // Provincias
  const provSet = new Set();
  const provMap = new Map();
  for (const p of provArr){
    const canon = String(p||"").trim();
    if (!canon) continue;
    provSet.add(canon);
    const k = _normKey(canon);
    if (!provMap.has(k)) provMap.set(k, canon);
  }

  // Municipios por provincia + √≠ndice global
  const muniByProv = new Map(); // provCanon -> Map(norm -> canonMun)
  const muniGlobal = new Map(); // norm -> {mun, prov}
  if (muniObj){
    for (const provKey of Object.keys(muniObj)){
      const list = Array.isArray(muniObj[provKey]) ? muniObj[provKey] : [];
      // En tu municipios.js la clave suele ser la provincia en may√∫sculas (sin tildes a veces). La normalizamos y la resolvemos a canon.
      const provCanon = provMap.get(_normKey(provKey)) || String(provKey||"").trim();
      if (!muniByProv.has(provCanon)) muniByProv.set(provCanon, new Map());
      const mMap = muniByProv.get(provCanon);
      for (const m of list){
        const mun = String(m||"").trim();
        if (!mun) continue;
        const mk = _normKey(mun);
        if (!mMap.has(mk)) mMap.set(mk, mun);
        // √çndice global (si hay duplicados entre provincias, nos quedamos con el primero; para domicilio/nacimiento normalmente hay prov)
        if (!muniGlobal.has(mk)) muniGlobal.set(mk, { mun, prov: provCanon });
      }
    }
  }

  // Pa√≠ses (aplana PAISES.groups/items)
  const paisSet = new Set();
  const paisMap = new Map();
  try{
    const P = window.PAISES;
    const addPais = (x)=>{
      const c = String(x||"").trim();
      if (!c) return;
      paisSet.add(c);
      const k=_normKey(c);
      if(!paisMap.has(k)) paisMap.set(k,c);
    };
    if (P){
      if (Array.isArray(P.featured)) P.featured.forEach(addPais);
      if (Array.isArray(P.groups)){
        P.groups.forEach(g=>{
          if (g && Array.isArray(g.items)) g.items.forEach(addPais);
        });
      }
    }
  }catch(_){/* noop */}

  return { provSet, provMap, muniByProv, muniGlobal, paisSet, paisMap };
}

const __CANON = _buildCanonIndexes();

function canonProvincia(raw){
  const k = _normKey(raw);
  return __CANON.provMap.get(k) || "";
}

function canonMunicipio(raw, provCanon){
  const mk = _normKey(raw);
  if (!mk) return "";
  if (provCanon && __CANON.muniByProv.has(provCanon)){
    const m = __CANON.muniByProv.get(provCanon).get(mk);
    if (m) return m;
  }
  const g = __CANON.muniGlobal.get(mk);
  return g ? g.mun : "";
}


function canonPais(raw){
  const k = _normKey(raw);
  return __CANON.paisMap.get(k) || "";
}

// --- ISO3 (MRZ) ‚Üí Pa√≠s can√≥nico (PAISES.js) ---
// Nota: PAISES.js contiene nombres en castellano (may√∫sculas). El MRZ suele traer ISO-3166-1 alpha-3.
const ISO3_TO_PAIS = {
  // Europa
  ESP: "ESPA√ëA",
  PRT: "PORTUGAL",
  FRA: "FRANCIA",
  DEU: "ALEMANIA",
  ITA: "ITALIA",
  NLD: "PAISES BAJOS",
  BEL: "BELGICA",
  LUX: "LUXEMBURGO",
  CHE: "SUIZA",
  AUT: "AUSTRIA",
  GBR: "REINO UNIDO",
  IRL: "IRLANDA",
  ISL: "ISLANDIA",
  NOR: "NORUEGA",
  SWE: "SUECIA",
  FIN: "FINLANDIA",
  DNK: "DINAMARCA",
  POL: "POLONIA",
  CZE: "REPUBLICA CHECA",
  SVK: "REPUBLICA ESLOVACA",
  HUN: "HUNGRIA",
  ROU: "RUMANIA",
  BGR: "BULGARIA",
  GRC: "GRECIA",
  CYP: "CHIPRE",
  HRV: "CROACIA",
  SVN: "ESLOVENIA",
  EST: "ESTONIA",
  LVA: "LETONIA",
  LTU: "LITUANIA",
  UKR: "UCRANIA",
  RUS: "RUSIA",
  BLR: "BIELORRUSIA",
  SRB: "SERBIA",
  MNE: "MONTENEGRO",
  MKD: "MACEDONIA DEL NORTE",
  ALB: "ALBANIA",
  BIH: "BOSNIA HERZEGOVINA",
  MLT: "MALTA",
  AND: "ANDORRA",
  MCO: "MONACO",
  SMR: "SAN MARINO",
  VAT: "CIUDAD DEL VATICANO",
  LIE: "LIECHTENSTEIN",
  KOS: "KOSOVO",
  // Am√©rica
  USA: "ESTADOS UNIDOS AMERICA",
  CAN: "CANADA",
  MEX: "MEXICO",
  GTM: "GUATEMALA",
  HND: "HONDURAS",
  SLV: "EL SALVADOR",
  NIC: "NICARAGUA",
  CRI: "COSTA RICA",
  PAN: "PANAMA",
  CUB: "CUBA",
  DOM: "REPUBLICA DOMINICANA",
  HTI: "HAITI",
  JAM: "JAMAICA",
  COL: "COLOMBIA",
  VEN: "VENEZUELA",
  ECU: "ECUADOR",
  PER: "PERU",
  BOL: "BOLIVIA",
  CHL: "CHILE",
  ARG: "ARGENTINA",
  URY: "URUGUAY",
  PRY: "PARAGUAY",
  BRA: "BRASIL",
  GUY: "GUYANA",
  SUR: "SURINAME",
  BHS: "BAHAMAS",
  BRB: "BARBADOS",
  BLZ: "BELICE",
  ATG: "ANTIGUA Y BARBUDA",
  DMA: "DOMINICA",
  GRD: "GRANADA",
  KNA: "SAN CRISTOBAL Y NIEVES",
  LCA: "SANTA LUCIA",
  VCT: "SAN VICENTE Y LAS GRANADINAS",
  TTO: "TRINIDAD Y TOBAGO",
  // √Åfrica
  MAR: "MARRUECOS",
  DZA: "ARGELIA",
  TUN: "TUNEZ",
  LBY: "LIBIA",
  EGY: "EGIPTO",
  SDN: "SUDAN",
  SSD: "SUDAN DEL SUR",
  ETH: "ETIOPIA",
  SOM: "SOMALIA",
  KEN: "KENIA",
  TZA: "TANZANIA",
  UGA: "UGANDA",
  RWA: "RUANDA",
  BDI: "BURUNDI",
  COD: "REPUBLICA DEMOCRATICA CONGO",
  COG: "REPUBLICA CONGO",
  CMR: "CAMERUN",
  NGA: "NIGERIA",
  GHA: "GHANA",
  CIV: "COSTA MARFIL",
  SEN: "SENEGAL",
  MLI: "MALI",
  NER: "NIGER",
  TCD: "CHAD",
  GAB: "GABON",
  AGO: "ANGOLA",
  ZMB: "ZAMBIA",
  ZWE: "ZIMBABUE",
  BWA: "BOTSUANA",
  NAM: "NAMIBIA",
  ZAF: "SUDAFRICA",
  MOZ: "MOZAMBIQUE",
  MDG: "MADAGASCAR",
  CPV: "CABO VERDE",
  GIN: "GUINEA",
  GNB: "GUINEA BISSAU",
  SLE: "SIERRA LEONA",
  LBR: "LIBERIA",
  GMB: "GAMBIA",
  MRT: "MAURITANIA",
  ESH: "SAHARA OCCIDENTAL",
  // Asia
  TUR: "TURQUIA",
  ISR: "ISRAEL",
  PSE: "PALESTINA",
  LBN: "LIBANO",
  SYR: "SIRIA",
  IRQ: "IRAK",
  IRN: "IRAN",
  SAU: "ARABIA SAUDI",
  ARE: "EMIRATOS ARABES UNIDOS",
  QAT: "CATAR",
  KWT: "KUWAIT",
  OMN: "OMAN",
  YEM: "YEMEN",
  JOR: "JORDANIA",
  AFG: "AFGANISTAN",
  PAK: "PAKISTAN",
  IND: "INDIA",
  BGD: "BANGLADESH",
  LKA: "SRI LANKA",
  NPL: "NEPAL",
  BTN: "BUTAN",
  MMR: "BIRMANIA",
  THA: "TAILANDIA",
  VNM: "VIETNAM",
  KHM: "CAMBOYA",
  LAO: "LAOS",
  MYS: "MALASIA",
  SGP: "SINGAPUR",
  IDN: "INDONESIA",
  PHL: "FILIPINAS",
  CHN: "CHINA",
  JPN: "JAPON",
  KOR: "COREA DEL SUR",
  PRK: "COREA DEL NORTE",
  MNG: "MONGOLIA",
  KAZ: "KAZAJISTAN",
  KGZ: "KIRGUISTAN",
  TJK: "TAYIKISTAN",
  TKM: "TURKMENISTAN",
  UZB: "UZBEKISTAN",
  GEO: "GEORGIA",
  ARM: "ARMENIA",
  AZE: "AZERBAYAN",
  // Ocean√≠a
  AUS: "AUSTRALIA",
  NZL: "NUEVA ZELANDA",
  PNG: "PAPUA NUEVA GUINEA",
  FJI: "FIYI",
  SLB: "ISLAS SALOMON",
  MHL: "ISLAS MARSHALL",
  FSM: "MICRONESIA",
  KIR: "KIRIBATI",
  NRU: "NAURU",
  PLW: "PALAOS",
  WSM: "SAMOA",
  TON: "TONGA",
  TUV: "TUVALU",
  VUT: "VANUATU"
};

function iso3ToPaisName(raw){
  const s = (raw||"").toString().trim().toUpperCase();
  if (!s) return "";
  if (/^[A-Z]{3}$/.test(s)) return ISO3_TO_PAIS[s] || "";
  return "";
}

function enforceCanonicalNacionalidad(){
  const el = document.getElementById('Nacionalidad');
  if (!el || !el.value) return;

  const raw0 = el.value.toString().trim();
  if (!raw0) return;

  // 1) Si viene ISO3 (ESP/GBR/IND...), convi√©rtelo a nombre objetivo en castellano
  const isoHit = iso3ToPaisName(raw0);
  const raw = isoHit || raw0;

  // 2) Canoniza contra PAISES.js (literal exacto)
  const canon = canonPais(raw);
  if (canon){
    el.value = tcase(canon);
  }
}

// Aplica correcci√≥n can√≥nica a:
//  - Lugar (nacimiento): "Municipio, Provincia" o solo "Provincia"
//  - Domicilio: intenta corregir los 2 √∫ltimos tokens como "Municipio, Provincia"
function enforceCanonicalLugarYDomicilio(){
  // Si no hay cat√°logos cargados, no hacemos nada.
  const hasProv = (__CANON.provMap && __CANON.provMap.size);
  const hasMuni = (__CANON.muniGlobal && __CANON.muniGlobal.size);
  if (!hasProv && !hasMuni) return;

    // --- NACIMIENTO (Lugar) ---
  const lugarEl = document.getElementById('Lugar');
  const natEl = document.getElementById('Nacionalidad');

  // Nacionalidad can√≥nica (para decidir si es Espa√±a y para fallback)
  const natRaw0 = (natEl && natEl.value) ? natEl.value.toString().trim() : "";
  const natIso  = iso3ToPaisName(natRaw0);
  const natCanon = canonPais(natIso || natRaw0);
  const natCanonNorm = _normKey(natCanon);
  const espNorm = _normKey(canonPais('ESPA√ëA') || 'ESPA√ëA');
  const natIsSpain = !!natCanon && (natCanonNorm === espNorm);

  // Si no hay Lugar pero hay Nacionalidad extranjera, imponemos pa√≠s = nacionalidad.
  if (lugarEl && (!lugarEl.value || !lugarEl.value.toString().trim())){
    if (natCanon && !natIsSpain){
      lugarEl.value = `${tcase(natCanon)}`;
    }
  }

  if (lugarEl && lugarEl.value){
    const raw = lugarEl.value.toString().trim();

    // REGLA PRIORITARIA:
    // Si la nacionalidad NO es Espa√±a => Lugar debe ser SIEMPRE un PA√çS.
    // Por defecto: Lugar = Nacionalidad.
    // Solo usamos otro pa√≠s si Lugar contiene un pa√≠s v√°lido distinto.
    if (natCanon && !natIsSpain){
      const parts2 = raw.split(',').map(s=>s.trim()).filter(Boolean);
      const lastTok = parts2.length ? parts2[parts2.length-1] : raw;

      const isoHit = iso3ToPaisName(lastTok) || iso3ToPaisName(raw);
      const paisTry = canonPais(isoHit || lastTok) || canonPais(raw);

      // Si Lugar trae un pa√≠s v√°lido y es distinto, √∫salo; si no, fuerza nacionalidad.
      const finalPais = (paisTry && _normKey(paisTry) !== natCanonNorm) ? paisTry : natCanon;
      lugarEl.value = `${tcase(finalPais)}`;
    } else {
      // Nacionalidad Espa√±a (o no disponible): l√≥gica Espa√±a municipio/provincia
      const parts = raw.split(',').map(s=>s.trim()).filter(Boolean);
      let munRaw = "", provRaw = "";
      if (parts.length >= 2){
        provRaw = parts[parts.length-1];
        munRaw  = parts.slice(0, parts.length-1).join(', ');
      } else if (parts.length === 1){
        const p = canonProvincia(parts[0]);
        if (p) provRaw = parts[0];
        else munRaw = parts[0];
      }

      const provCanon = provRaw ? canonProvincia(provRaw) : "";
      const munCanon  = munRaw ? canonMunicipio(munRaw, provCanon) : "";

      if (provCanon && munCanon){
        lugarEl.value = `${tcase(munCanon)}, ${tcase(provCanon)}`;
      } else if (provCanon && !munCanon){
        lugarEl.value = `${tcase(provCanon)}`;
      } else if (!provCanon && munCanon){
        lugarEl.value = `${tcase(munCanon)}`;
      } else {
        // Fallback extranjero: SOLO pa√≠s. Si no hay pa√≠s v√°lido, y hay nacionalidad, usa nacionalidad.
        const parts2 = raw.split(',').map(s=>s.trim()).filter(Boolean);
        const lastTok = parts2.length ? parts2[parts2.length-1] : raw;
        const isoHit = iso3ToPaisName(lastTok) || iso3ToPaisName(raw);
        const paisTry = canonPais(isoHit || lastTok) || canonPais(raw);

        const finalPais = paisTry || natCanon;
        if (finalPais){
          lugarEl.value = `${tcase(finalPais)}`;
        }
      }
    }
  }

  // --- DOMICILIO ---
  const domEl = document.getElementById('Domicilio');
  if (domEl && domEl.value){
    const raw = domEl.value.toString().trim();
    const parts = raw.split(',').map(s=>s.trim()).filter(Boolean);
    if (parts.length >= 2){
      const provRaw = parts[parts.length-1];
      const munRaw  = parts[parts.length-2];
      const provCanon = canonProvincia(provRaw);
      const munCanon  = canonMunicipio(munRaw, provCanon);

      // Solo reescribimos si al menos provincia o municipio se pueden canonizar.
      if (provCanon || munCanon){
        const newParts = parts.slice(0, -2);
        newParts.push(munCanon ? tcase(munCanon) : tcase(munRaw));
        newParts.push(provCanon ? tcase(provCanon) : tcase(provRaw));
        domEl.value = newParts.join(', ');
      }
    }
  }
}

// ---------- UI ----------
function validateField(el, force=false){
  if (!el) return;
  const value = (el.value || "").trim();

  let ok = false;
  if (el.tagName === "INPUT" || el.tagName === "TEXTAREA"){
    ok = value.length >= 2;
  } else if (el.tagName === "SELECT"){
    ok = value !== "";
  }

  // No pintar en rojo al inicio: solo marcar invalid si el usuario ya toc√≥ el campo,
  // o si se fuerza validaci√≥n.
  const touched = el.dataset.touched === "1";
  if (!force && !touched && !value){
    el.classList.remove("valid","invalid");
    return;
  }

  el.classList.toggle("valid", ok);
  el.classList.toggle("invalid", !ok);
}

function validateAll(){
  ["Nombre","Apellidos","Tipo","Numero","Sexo","Nacionalidad","Padres","Nacimiento","Lugar","Domicilio","Telefono","Condicion"]
    .forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      validateField(el);
    });
}
function updateCount(){
  // App para una sola filiaci√≥n: sin contador/lista
}
function renderLista(){
  // App para una sola filiaci√≥n: sin lista
}
function getFormAsFiliacion(){
  return {
    "Nombre": document.getElementById('Nombre').value,
    "Apellidos": (document.getElementById('Apellidos').value||"").toUpperCase(),
    "Tipo de documento": document.getElementById('Tipo').value,
    "N¬∫ Documento": document.getElementById('Numero').value,
    "Sexo": document.getElementById('Sexo').value,
    "Nacionalidad": document.getElementById('Nacionalidad').value,
    "Nombre de los Padres": document.getElementById('Padres').value,
    "Fecha de nacimiento": document.getElementById('Nacimiento').value,
    "Lugar de nacimiento": document.getElementById('Lugar').value,
    "Domicilio": document.getElementById('Domicilio').value,
    "Tel√©fono": document.getElementById('Telefono').value,
    "Condici√≥n": document.getElementById('Condicion').value
  };
}
function fillFormFromParsed(p){
  // Fallback: si solo viene un "nombre completo" de 2 palabras metido entero en Nombre o en Apellidos,
  // rep√°rtelo en 1 nombre + 1 apellido.
  // Casos:
  //  - Nombre vac√≠o y Apellidos="PRABHDEEP SINGH" => Nombre="Prabhdeep" / Apellidos="SINGH"
  //  - Apellidos vac√≠o y Nombre="PRABHDEEP SINGH" => Nombre="Prabhdeep" / Apellidos="SINGH"
  (function(){
    const n0 = (p && p.Nombre != null) ? String(p.Nombre).trim() : "";
    const a0 = (p && p.Apellidos != null) ? String(p.Apellidos).trim() : "";

    const split2 = (s) => String(s || "").trim().split(/\s+/).filter(Boolean);

    // Apellidos tiene 2 palabras y Nombre est√° vac√≠o
    if (!n0 && a0) {
      const toks = split2(a0);
      if (toks.length === 2) {
        p.Nombre = tcase(toks[0]);
        p.Apellidos = String(toks[1]).toUpperCase();
      }
    }

    // Nombre tiene 2 palabras y Apellidos est√° vac√≠o
    if (!a0 && n0) {
      const toks = split2(n0);
      if (toks.length === 2) {
        p.Nombre = tcase(toks[0]);
        p.Apellidos = String(toks[1]).toUpperCase();
      }
    }
  })();
  if(p.Nombre!=null)  document.getElementById('Nombre').value = p.Nombre;
  if(p.Apellidos!=null) document.getElementById('Apellidos').value = p.Apellidos;
  if(p["Tipo de documento"]!=null) document.getElementById('Tipo').value = p["Tipo de documento"];
  if(p["N¬∫ Documento"]!=null) document.getElementById('Numero').value = p["N¬∫ Documento"];
  if(p.Sexo!=null) document.getElementById('Sexo').value = p.Sexo;
  if(p.Nacionalidad!=null) document.getElementById('Nacionalidad').value = p.Nacionalidad;
  if(p["Nombre de los Padres"]!=null) document.getElementById('Padres').value = p["Nombre de los Padres"];
  if(p["Fecha de nacimiento"]!=null) document.getElementById('Nacimiento').value = p["Fecha de nacimiento"];
  if(p["Lugar de nacimiento"]!=null) document.getElementById('Lugar').value = p["Lugar de nacimiento"];
  if(p.Domicilio!=null) document.getElementById('Domicilio').value = p.Domicilio;

for (const id of ['Nombre','Apellidos','Padres','Lugar','Domicilio','Numero']){
    document.getElementById(id)?.classList.remove('uncertain');
  }
  if (p._flags){
    if (p._flags.Nombre) document.getElementById('Nombre')?.classList.add('uncertain');
    if (p._flags.Apellidos) document.getElementById('Apellidos')?.classList.add('uncertain');
    if (p._flags.Padres) document.getElementById('Padres')?.classList.add('uncertain');
    if (p._flags.Lugar) document.getElementById('Lugar')?.classList.add('uncertain');
    if (p._flags.Domicilio) document.getElementById('Domicilio')?.classList.add('uncertain');
  if (p._flags.Numero) document.getElementById('Numero')?.classList.add('uncertain');
  }

  enforceCanonicalNacionalidad();
  enforceCanonicalLugarYDomicilio();
  validateAll();
}
function clearFormOnly(){
  ["Nombre","Apellidos","Tipo","Numero","Sexo","Nacionalidad","Padres","Nacimiento","Lugar","Domicilio","Telefono","Condicion"]
    .forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      el.value = "";
      el.classList.remove('uncertain','valid','invalid');
      delete el.dataset.touched;
    });

  const ta = document.getElementById('Doc');
  if (ta) ta.value = "";

  // No revalidamos aqu√≠: la escoba debe dejar todo visualmente limpio
  updateCount();
}
function processOCR(ocr){
  if(!ocr.trim()){ alert("Portapapeles vac√≠o. Copia el OCR primero."); return; }
const parsed = parseDocument(ocr);
  fillFormFromParsed(parsed);
}

// ---------- eventos ----------
const btnFoto = document.getElementById('readAnalyze');
const btnArchivo = document.getElementById('readAnalyzeFile');
const inputFoto = document.getElementById('dniCameraInput');
const inputArchivo = document.getElementById('dniFileInput');

if (btnFoto && inputFoto){
  btnFoto.addEventListener('click', () => {
    inputFoto.value = "";
    inputFoto.click();
  });
}

if (btnArchivo && inputArchivo){
  btnArchivo.addEventListener('click', () => {
    inputArchivo.value = "";
    inputArchivo.click();
  });
}
document.getElementById('gptComparecencia').addEventListener('click', ()=>{
  window.open('https://chatgpt.com/g/g-69014d0cf61881918dd3773943228c6b-gtd','_blank','noopener');
});
document.getElementById('btnDiligencia').addEventListener('click', ()=>{
  window.open('https://chatgpt.com/g/g-693d60e869b48191908e1ac278901882-motor-documental-formal','_blank','noopener');
});
async function readFromClipboard(){
  try{ const txt = await navigator.clipboard.readText(); return txt || ""; }
  catch{ const m = prompt("Pega manualmente el texto:"); return m || ""; }
}
document.getElementById('integrarDoc').addEventListener('click', async ()=>{
  const txt = await readFromClipboard();
  if (!txt.trim()) { alert("Portapapeles vac√≠o."); return; }
  document.getElementById('Doc').value = txt;
  expediente.doc = txt;
});
document.getElementById('clearForm').addEventListener('click', clearFormOnly);
document.getElementById('Doc').addEventListener('input', (e)=>{ expediente.doc = e.target.value; });
const btnDownload = document.getElementById('download');
if (btnDownload){
  btnDownload.addEventListener('click', ()=>{
    // Si hay datos en la ficha actual, se guardan autom√°ticamente (1 sola filiaci√≥n)
const f = getFormAsFiliacion();
const anyVal = Object.values(f).some(v => (v||"").trim()!=="");

if (anyVal){
  // Condici√≥n obligatoria tambi√©n en descarga
  const condEl = document.getElementById('Condicion');
  const cond = (condEl?.value || "").trim();
  if (!cond){
    alert("Selecciona la Condici√≥n (obligatoria) antes de descargar.");
    condEl?.focus();
    condEl?.classList.add('invalid');
    return;
  }
  condEl?.classList.remove('invalid');
  condEl?.classList.add('valid');

  // Persistimos la filiaci√≥n actual en el expediente (√∫nica)
  expediente.filiaciones = [f];

  // Limpia el formulario tras capturar la filiaci√≥n (opcional, pero recomendable)
  clearFormOnly();
}

    expediente.doc = document.getElementById('Doc').value || expediente.doc || "";
    const data = { doc: expediente.doc, filiaciones: expediente.filiaciones };

    try{
      const jsonStr = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const d = new Date(); const pad = n => String(n).padStart(2,'0');
      const fname = `Proyecto ${pad(d.getHours())}-${pad(d.getMinutes())} ${pad(d.getDate())}_${pad(d.getMonth()+1)}_${d.getFullYear()}.json`;
      const a = document.createElement('a');
      a.href = url;
      a.download = fname;
      a.click();
      URL.revokeObjectURL(url);
    }catch(err){
      console.error("Error descargando el proyecto:", err);
      alert("No se ha podido descargar el proyecto.");
    }
  });
}

const btnLoadPlain = document.getElementById('loadPlain');
const inputPlain   = document.getElementById('plainInput');

if (btnLoadPlain && inputPlain){
  btnLoadPlain.addEventListener('click', () => {
    inputPlain.value = "";
    inputPlain.click();
  });

  inputPlain.addEventListener('change', (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try{
        const text = (ev.target.result || "").toString().trim();
        if (!text){
          alert("Archivo vac√≠o o no v√°lido.");
          return;
        }
        const data = JSON.parse(text);
        if (!data || typeof data !== "object") throw new Error("Formato inesperado");

        expediente.doc = data.doc || "";
        expediente.filiaciones = Array.isArray(data.filiaciones) ? data.filiaciones : [];

        // Limpiar campos del formulario (excepto DOC)
        ["Nombre","Apellidos","Tipo","Numero","Sexo","Nacionalidad","Padres","Nacimiento","Lugar","Domicilio","Telefono","Condicion"]
          .forEach(id => {
            const el = document.getElementById(id);
            if (el){ el.value = ""; el.classList.remove("uncertain","valid","invalid"); }
          });
        const docEl = document.getElementById('Doc');
        if (docEl) docEl.value = expediente.doc;
        updateCount();
        validateAll();
      }catch(err){
        console.error("Error al cargar el proyecto:", err);
        alert("No se ha podido cargar el proyecto. JSON inv√°lido o archivo da√±ado.");
      }
    };
    reader.readAsText(file);
  });
}

// init
["Nombre","Apellidos","Tipo","Numero","Sexo","Nacionalidad","Padres","Nacimiento","Lugar","Domicilio","Telefono","Condicion"].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;

  const markTouchedAndValidate = (force=false)=>{
    el.dataset.touched = "1";
    validateField(el, force);
  };

  // Validar al salir del campo
  el.addEventListener("blur", () => markTouchedAndValidate(true));

  // En selects, tambi√©n al cambiar la opci√≥n
  if (el.tagName === "SELECT"){
    el.addEventListener("change", () => markTouchedAndValidate(true));
  }
});

updateCount();
validateAll();
initMunicipios();
initNombres();
</script>
<script>

let OCR_API_URL_DEFAULT = "https://ocr-vision-1054102077894.europe-west1.run.app";
let OCR_API_URL = OCR_API_URL_DEFAULT;

// ---------- Acceso (usuario/grupo) ----------
const AUTH_LS_KEY = "DECLARATRON_AUTH_V1";
let AUTH = { group:"", pass:"", apiUrl:"" };

function loadAuth(){
  try{
    const raw = localStorage.getItem(AUTH_LS_KEY);
    if (!raw) return;
    const obj = JSON.parse(raw);
    if (obj && typeof obj === 'object'){
      AUTH.group = String(obj.group||'').trim();
      AUTH.pass  = String(obj.pass||'').trim();
      AUTH.apiUrl= String(obj.apiUrl||'').trim();
      if (AUTH.apiUrl) OCR_API_URL = AUTH.apiUrl;
    }
  }catch(_){/* noop */}
}
function saveAuth(){
  localStorage.setItem(AUTH_LS_KEY, JSON.stringify(AUTH));
}
function clearAuth(){
  localStorage.removeItem(AUTH_LS_KEY);
  AUTH = { group:"", pass:"", apiUrl:"" };
  OCR_API_URL = OCR_API_URL_DEFAULT;
}

function authHeaders(){
  const h = {};
  if (AUTH.group) h["x-group"] = AUTH.group;
  if (AUTH.pass)  h["x-group-pass"] = AUTH.pass;
  return h;
}

function updateAuthUI(){
  const badge = document.getElementById('authBadge');
  const btnLogout = document.getElementById('btnLogout');
  const btnAuth = document.getElementById('btnAuth');
  if (!badge) return;

  const ok = !!(AUTH.group && AUTH.pass);
  badge.textContent = ok ? `Acceso: ${AUTH.group}` : 'Sin acceso';

  if (btnLogout) btnLogout.style.display = ok ? '' : 'none';
  if (btnAuth) btnAuth.style.display = ok ? 'none' : '';
}

function openAuthModal(){
  const modal = document.getElementById('authModal');
  if (!modal) return;
  modal.classList.add('open');
  modal.setAttribute('aria-hidden','false');
  const g = document.getElementById('authGroup');
  const p = document.getElementById('authPass');
  const u = document.getElementById('authApiUrl');
  if (g) g.value = AUTH.group || '';
  if (p) p.value = AUTH.pass  || '';
  if (u) u.value = (AUTH.apiUrl || OCR_API_URL_DEFAULT);
  setTimeout(()=>{ g?.focus(); }, 0);
}
function closeAuthModal(){
  const modal = document.getElementById('authModal');
  if (!modal) return;
  modal.classList.remove('open');
  modal.setAttribute('aria-hidden','true');
}

function wireAuthUI(){
  // Modal handlers
  document.getElementById('btnAuth')?.addEventListener('click', openAuthModal);
  document.getElementById('btnLogout')?.addEventListener('click', ()=>{
    clearAuth();
    updateAuthUI();
    alert('Acceso borrado.');
  });

  document.getElementById('authCancel')?.addEventListener('click', closeAuthModal);
  document.getElementById('authModal')?.addEventListener('click', (e)=>{
    if (e.target && e.target.id === 'authModal') closeAuthModal();
  });

  document.getElementById('authSave')?.addEventListener('click', ()=>{
    const g = (document.getElementById('authGroup')?.value || '').trim();
    const p = (document.getElementById('authPass')?.value  || '').trim();
    const u = (document.getElementById('authApiUrl')?.value|| '').trim();

    // URL opcional (si viene vac√≠o, usamos default)
    AUTH.group = g;
    AUTH.pass  = p;
    AUTH.apiUrl= u;
    OCR_API_URL = AUTH.apiUrl || OCR_API_URL_DEFAULT;

    saveAuth();
    updateAuthUI();
    closeAuthModal();

    if (!AUTH.group || !AUTH.pass){
      alert('Guardado. Ojo: sin grupo/contrase√±a no podr√°s usar el OCR.');
    }
  });
}

// init auth (antes de usar OCR_API_URL)
loadAuth();
const MAX_IMAGE_BYTES = 400 * 1024;
const TARGET_LONG_EDGE = 2200;

// Mapea el JSON del backend (index.html) al esquema que usa Fil.html (fillFormFromParsed)
function mapBackendToFilFields(p){
  const safe = v => (v == null ? "" : String(v));
  const sanitizeKeepComma = (s) => safe(s)
    // permite letras (incl. acentos), n√∫meros, espacios y , / - .
    .replace(/[^0-9A-Za-z√Ä-√ñ√ò-√∂√∏-√ø√ë√±\s,\/\-\.]/g, '')
    .replace(/\s+/g, ' ')
    .trim();

  const mrz2 = (p && Array.isArray(p.mrz) && p.mrz[1]) ? String(p.mrz[1]).replace(/\s+/g,'') : "";

  // 1) Prioridad: si el backend ya trae Sexo en texto, √∫salo tal cual.
  const normSexo = (v)=>{
    const s = safe(v).trim().toUpperCase();
    if (!s) return "";
    if (s.startsWith('F')) return 'FEMENINO';
    if (s.startsWith('M')) return 'MASCULINO';
    return (s === 'FEMENINO' || s === 'MASCULINO') ? s : "";
  };

  let sexo = normSexo(p?.final?.Sexo || p?.Sexo || p?.sexo || "");

  // 2) Fallback MRZ (si el backend no lo trae):
  // - PASAPORTE TD3 => sexo est√° en L2 charAt(20)
  // - DNI/NIE (IDESP) => mantenemos tu l√≥gica previa charAt(7)
  if (!sexo && mrz2) {
    const isPassport = String(p?.tipo_documento || '').toUpperCase() === 'PASAPORTE' || /^P</i.test(String((p?.mrz && p.mrz[0]) || ''));
    const sexoCode = isPassport
      ? ((mrz2.length >= 21) ? mrz2.charAt(20).toUpperCase() : "")
      : ((mrz2.length >= 8)  ? mrz2.charAt(7).toUpperCase()  : "");
    sexo = (sexoCode === 'F') ? 'FEMENINO' : (sexoCode === 'M') ? 'MASCULINO' : '';
  }

  const lugar = (p?.lugar_nacimiento && String(p.lugar_nacimiento).trim())
    ? String(p.lugar_nacimiento).trim()
    : [p?.lugar_nacimiento_municipio, p?.lugar_nacimiento_provincia]
        .filter(Boolean)
        .join(', ');

  // --- PATCH NIE VERDE (solo front): si backend manda el nombre completo en Apellidos y Nombre vac√≠o ---
  let _Nombre = sanitizeKeepComma(p?.nombre || '');
  let _Apellidos = sanitizeKeepComma(p?.apellidos || '').toUpperCase();
  const _Tipo = sanitizeKeepComma(p?.tipo_documento || 'DNI');

  // Solo aplicar a NIE (certificado UE). Evita tocar DNI/PASAPORTE.
  if (/\bNIE\b/i.test(_Tipo)) {
    const isTreatment = (s)=>{
      const t = String(s||'').trim().toUpperCase().replace(/\s+/g,'');
      if (!t) return true;
      const t2 = t.replace(/[^A-Z]/g,'');
      return t2 === 'D' || t2 === 'DD' || t2 === 'DA' || t2 === 'DDA';
    };

    if ((isTreatment(_Nombre) || !_Nombre) && _Apellidos) {
      const toks = _Apellidos.trim().split(/\s+/).filter(Boolean);
      if (toks.length >= 4) {
        _Nombre = toks.slice(0,2).join(' ');
        _Apellidos = toks.slice(2).join(' ');
      }
    }
  }

  return {
    Nombre: _Nombre,
    Apellidos: _Apellidos,
    "Tipo de documento": _Tipo,
    "N¬∫ Documento": sanitizeKeepComma(p?.numero_documento || ''),
    Nacionalidad: sanitizeKeepComma(p?.nacionalidad || ''),
    "Fecha de nacimiento": sanitizeKeepComma(p?.fecha_nacimiento || ''),
    "Lugar de nacimiento": sanitizeKeepComma(lugar),
    "Nombre de los Padres": sanitizeKeepComma(safe(p?.hijos_de || '').replace(/\s*\/\s*/g, ' y ')),
    Domicilio: sanitizeKeepComma(p?.domicilio || ''),
    Sexo: sexo,
    _flags: {}
  };
}

document.getElementById('dniCameraInput').addEventListener('change', async (e) => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  if (!ensureAuthOrPrompt()) return;

  try {
    const dataUrl = await fileToDataUrl(file);
    const res = await fetch(OCR_API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json", ...authHeaders() },
      body: JSON.stringify({ imageBase64: dataUrl })
    });

    const text = await res.text();
    if (!res.ok) throw new Error(text);

    const json = JSON.parse(text);
    if (!json || json.ok !== true || !json.parsed) throw new Error("Respuesta inv√°lida del backend");

    const mapped = mapBackendToFilFields(json.parsed || {});
    fillFormFromParsed(mapped);
  } catch (err) {
    console.error(err);
    try{
      const docEl = document.getElementById('Doc');
      if (docEl) docEl.value = "[OCR ERROR]\n" + String(err?.message || err);
    }catch(_){/* no-op */}
    alert("Error al procesar la imagen del DNI. Revisa consola.");
  }
});

document.getElementById('dniFileInput').addEventListener('change', async (e) => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  if (!ensureAuthOrPrompt()) return;

  try {
    const dataUrl = await fileToDataUrl(file);
    const res = await fetch(OCR_API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json", ...authHeaders() },
      body: JSON.stringify({ imageBase64: dataUrl })
    });

    const text = await res.text();
    if (!res.ok) throw new Error(text);

    const json = JSON.parse(text);
    if (!json || json.ok !== true || !json.parsed) throw new Error("Respuesta inv√°lida del backend");

    const mapped = mapBackendToFilFields(json.parsed || {});
    fillFormFromParsed(mapped);
  } catch (err) {
    console.error(err);
    try{
      const docEl = document.getElementById('Doc');
      if (docEl) docEl.value = "[OCR ERROR]\n" + String(err?.message || err);
    }catch(_){/* no-op */}
    alert("Error al procesar la imagen del DNI. Revisa consola.");
  }
});

// ---------- Reducci√≥n autom√°tica de imagen ----------
function fileToDataUrl(file) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const url = URL.createObjectURL(file);

    img.onload = async () => {
      try {
        let w = img.width;
        let h = img.height;
        const longEdge = Math.max(w, h);

        if (longEdge > TARGET_LONG_EDGE) {
          const scale = TARGET_LONG_EDGE / longEdge;
          w = Math.round(w * scale);
          h = Math.round(h * scale);
        }

        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d", { alpha: false });
        ctx.drawImage(img, 0, 0, w, h);

        let quality = 0.9;
        let dataUrl = canvas.toDataURL("image/jpeg", quality);

        while (dataUrl.length * 0.75 > MAX_IMAGE_BYTES && quality > 0.5) {
          quality -= 0.05;
          dataUrl = canvas.toDataURL("image/jpeg", quality);
        }

        URL.revokeObjectURL(url);
        resolve(dataUrl);
      } catch (e) {
        URL.revokeObjectURL(url);
        reject(e);
      }
    };

    img.onerror = (e) => {
      URL.revokeObjectURL(url);
      reject(e);
    };

    img.src = url;
  });
}

// UI init (deferred: el modal est√° despu√©s de este <script>)
window.addEventListener('DOMContentLoaded', ()=>{
  wireAuthUI();
  updateAuthUI();
});

// Si no hay credenciales, abre el modal al intentar usar OCR (sin bloquear el resto de la app)
function ensureAuthOrPrompt(){
  if (AUTH.group && AUTH.pass) return true;
  openAuthModal();
  alert('Configura el acceso (grupo/contrase√±a) para usar el OCR.');
  return false;
}
</script>
<!-- Modal de acceso -->
<div class="modal" id="authModal" aria-hidden="true">
  <div class="panel" role="dialog" aria-modal="true" aria-labelledby="authTitle">
    <h2 id="authTitle">Acceso</h2>
    <div class="fields2">
      <div>
        <label>Usuario</label>
        <input id="authGroup" autocomplete="username" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
      </div>
      <div>
        <label>Contrase√±a</label>
        <input id="authPass" type="password" autocomplete="current-password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
      </div>

      <div class="span2 row center" style="margin-top:10px">
        <button class="btn" id="authSave">Guardar</button>
        <button class="btn secondary" id="authCancel">Cancelar</button>
      </div>
    </div>
  </div>
</div>
</body>
</html>
